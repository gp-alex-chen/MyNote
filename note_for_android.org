
#+STYLE: <link rel="stylesheet" type="text/css" href="http://orgmode.org/worg/worg.css" />
#+OPTIONS: ^:nil toc:2

* 事件监听
给按钮添加事件监听
setOnClickListener() 传入一个 OnClickListener() ,(一个监听者,并负责处理)
添加事件监听的四种方式
1. 匿名内部类
2. 内部类
3. 让 Activity 去实现监听接口
4. 在xml文件中设置 android:onClick ="函数名",并在 activity 中添加 public void 函数名(View v)方法
** 接口回调
接口回调就是指利用一个监听器来监听一个不知道什么时候会完成的方法，一旦方法完成，
调用回调方法通知调用者. Button 控件的监听事件就是一个典型的接口回调。
*** 接口回调的更多应用
- 在下载资源过程中，下载不知道什么时候完成，如果下载资源需要显示在 View 上，那么设置
 一个接口，其中定义一个完成方法，在资源下载完成后调用该方法，然后在 View 中设置接口,
 完成接口中的完成方法，即：方法调用时就表示资源已经下载成功，可以将其显示在 View 中.
- Fragment 与 Activity 之间传递信息可以在 Fragment 中设置接口， 在 Activity 中回调

* 找碧油鸡
输出去 logCat 中看
** logCat 的日志
#+BEGIN_SRC java
 Log.d(TAG,"debug");
 Log.i(TAG,"information");
 Log.e(TAG,"error");
 Log.w(TAG,"warn");
#+END_SRC
** 找BUG
添加一个DEBUG模式，发布时设置为false不打印LOG
** DeBugMode
定义一个自己的类 MyLog，在其中使用Log.d，但是在之前添加一个判断，判断的值在类中定义，这样在上线后将值改变为 false，就可以取消 Log 的打印

* View

** 一些公共的属性解释
| 属性              | 描述                                 | 备注                                      |
| layout_width      | 宽                                    |                                             |
| layout_height     | 高                                   |                                             |
| dp:               | 单位像素密度               |                                             |
| match_parent:     | 匹配上一级                        |                                             |
| wrap_content:     | 将内容完全显示出               |                                             |
| layout_weight:    | 权重,占比                          | 需要将 width 或者 height 设置为0dp,才有效果 |
| layout_gravity:   | 本视图相对于上一级视图的显示位置 |                                             |
| gravity:          | 视图中显示的内容相对于本视图的显示位置 |                                             |
| layout_marginxxx: | 外边距.                             |                                             |
| padding:          | 内边距                              |                                             |

** 关于颜色
: RGB 每个颜色值是一个1位的16进制数,0-f
: RRGGBB 每个颜色值是一个2位16进制,00-ff
: ARGB A表示透明度0表示完全透明 f不透明
: AARRGGBB 同上
** 布局(容器视图( View ))
作用:控制视图的显示位置

*** LinearLayout :线性布局
用 orientation 属性设置水平 horizontal 和垂直 virtical 方向

*** RelativeLayout:相对布局
可以方便的摆放控件
**** 相对同一级
- layout_toRightOf="id":本控件放在id为id的控件右边
- lalayout_below="id":在id的下方yout_below="id":在id的下方
- layout_alignLeft="id":与id左对齐
- layout_alignBaseline="id":与id基线对齐

**** 相对上一级
- layout_alignParentRight:是否在父容器的右方
- layout_centerInParent:是否在父容器的中央

*** FrameLayout:帧布局
显示一系列图片.

*** AutoCompleteTextView
其本身是一个容器视图,可以容纳其他视图
- completionThreshold : 用户输入'几'个字符后出现自动补全,默认值是2 
[[adapter][查看adapter内容]]
*** Spinner
下拉选单

放置数组
: entries="@array/list";

依旧需要添加[[adapter][Adapter]]适配器

事件监听
#+BEGIN_EXAMPLE
setOnItemSelectedListener(new OnItemSelectedListener)
#+END_EXAMPLE

实现 onItemSelected(AdapterView<?> parent, View view, int position,long id)

其中
: AdapterView<?>放置的是适配器容器视图,比如 Spinner

: view 接受的是现实被选中的数据项的 TextView 对象,就是适配器中的

: position 表示被选中的数据在适配器中的位置,即适配器中集合的位置.

取消默认选择第一项
: setSelection(0,true);//让第一项被选中过
记录一些基础控件
** 控件

*** textview
- textsize:字体大小
- textColor:颜色
- textStyle:风格
- drawableLeft:左边显示图片
- text:内容
- autoLink="...":设置内容为一个"..."类型的链接可以使web,phone等等
- singleLine:单行显示文本
- ellipsize:单行文本不够则显示省略号
- focusable 和 focusableInTouchMode:实现触摸得到焦点
- autoLink 自动识别格式，比如 email tel 等等

*** button
基本属性和 TextView 相同
- onClick="方法名"
**** 监听接口
OnClickedListener

*** togglebutton和Switch
开关

*** ImageView
图片视图
- src:设置图片源
- adjustViewBounds:当自身宽高发生变化时,图片按比例缩放
- minWidth:扩大的最大值
- maxHeight:扩大的最大值
- visibility:是否可见
- scaleType:填充方式
- setAlpha:设置透明度,0-1


**** scaleType
- centerCrop :: 以中心点为基准，等比缩放，以最短边填满 imageView 图片可能被截断
- centerInside :: 以中心点为基准，等比缩放，以最长边填充 imageView 图片会全部显示，只是可能占不满 imageView
*** EditText
可输入的文本框
- hint:默认显示的内容
- inputType:输入的内容类型

*** CheckBox
复选框,可以选择多项
- checked:是否选中
- onClick:点击调用相应方法
**** 方法
监听接口
: OnCheckedChangeListener
是否选中
: isCheaked

*** RadioButton
只能选中一个的单选框,要想实现单选,需要将 RadioButton 放到 RadioGroup 中.
如此,需要给组添加事件监听
: OnCheckedChangeListener()

*** ListView
ListView 的使用需要借助适配器，可以使用 ArrayAdapter 适配器，简单的使用 TextView，使用 [[BaseAdapter]] 
可以自定义视图，是常用控件之一.


**** 分页显示
在设置了 ListView 的数据后
#+BEGIN_SRC java
  //给 listView 添加事件监听，滑动时的
  listView.setOnScrollListener(new OnScrollListener);
  /*其中两个方法
  firstVisibleItem:已经出现过的不可见的数据个数
  visibleItemCount:可见的数据项个数
  totalItemCount:数据项总个数
  滑到底部： firstVisibleItem + visibleItemCount = totalItemCount;
  ,*/
  OnScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
           int totalItemCount);
  /*
    SCROLL_STATE_TOUCH_SCROLL:用手滑动屏幕，没有离开
    SCROLL_STATE_IDLE:用手滑动屏幕，但是已经松手
    SCROLL_STATE_FLING: 屏幕的惯性滑动
  */
  OnScrollStateChanged(AbsListView view, int scrollState){
      //当已经滑到所有数据项的底部并且已经松手更新数据
  }
#+END_SRC
小例子
#+BEGIN_SRC java
listView.setOnScrollListener(new AbsListView.OnScrollListener() {
           @Override
           public void onScrollStateChanged(AbsListView view, int scrollState) {
               if (isBottom && scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE) {
                   Toast.makeText(getActivity().getApplicationContext(), "loading...", Toast.LENGTH_SHORT).show();
               }
           }

           @Override
           public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
               isBottom = (firstVisibleItem + visibleItemCount) == totalItemCount;
           }
       });
#+END_SRC
*** ProgressDialog
进度对话框
#+BEGIN_SRC java
  Dialog dialog = new ProgressDialog(this);
  dialog.setTitle();
  dialog.setMessage();
  dialog.setProgressStyle(setProgressStyle.SYTLE...);
#+END_SRC
[[异步任务][异步任务相关]]

*** GridView
网格布局，相比 ListView 增加的属性
| 属性              | 描述               |
| numColumns        | 列数               |
| horizontalSpacing | 水平间距           |
| verticalSpacing   | 竖直间距           |
| columnWidth       | 列宽               |
| stretchMode       | 剩余宽度的分配方式 |

*** ScrollView
- scrollbars="none"--删除滚动滑块

** 获取屏幕的长宽
* Menu
** 系统菜单
位于menu下的main.xml,一个item就是一个菜单项

属性解释
- showAsAction：是否时动作项

#+BEGIN_QUOTE
在 Activity 中重写 onCreateOptionsMenu(Menu menu).
#+END_QUOTE
事件监听 
: onOptionsItemSelected
*** 使用反射来显示菜单项的图标
** <<上下文菜单>>
1. 为UI视图注册上下文菜单,在长按时创建 
 : registerForContextMenu(view);
2. 重写 
 : onCreateContextMenu(menu,view,menuInfo)
3. 填充按钮UI
 : getMenuInflater().inflate(R.menu.main, menu)
4. 重写 
 : onContextItemSelected(Menu item)

如果点击的是 ListView 的内容，那么下列代码可以得到 ListView 的 position
: AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo(); 

** 弹出菜单 PopupMenu
#+BEGIN_SRC java
  PopupMenu pop = new PopupMenu(this,v);
  getMenuInflater().inflate(R.menu.main,pop.getMenu());
  pop.setOnMenuItemClickListener(new OnMenuItemClickLinstener);    
#+END_SRC

* Dialog
** AlertDialog
对话框的初始化
- 创建对话框构建器对象
 : AlertDialog.Builder builder  = new AlertDialog.Builder(this);
- 使用对话框构建器对象初始化对话框的属性
 : builder.setTitle("name").setMessage("message").setIcon("图标”).setCancelable(false).setPositiveButton("确定",事件监听).set...
- 生成对话框
 : builder.create().show();
*** 连按回退键出现退出对话框
#+BEGIN_SRC java
  @Override
  public boolean onKeyDown(int KeyCode,KeyEvent event){
      if(KeyCode == KeyEvent.KEYCODE_BACK);
      dialog.show();
  }
  #+END_SRC

* Notification
Notification 就是通知。
** 构建器
#+BEGIN_SRC java 
  NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
  builder.setContentTitle();
  builder.setContetnText();
  builder.setSmallIcon();
  builder.setOngoing(true);
  Notification n = builder.build();
  NotificationManager manager = getSystemService(Content.xxxNOTIFICATION_SERVICE);
  manager.notify();
#+END_SRC
** 显示带详情的通知/点击之后出现详情页
#+BEGIN_SRC java
  NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
  builder.setContentTitle().setContentText().setSmallIcon()
      .setDefaults(Notification.DEFAULT_ALL);
  Intent intent = new Intent(this,MainActivity.class);
      //当通知被点击时，自动执行 startActivity
  PendingIntent pendingIntent = PendingIntent.getActivity(this,6,intent,PendingIntent.FLAG);
  builder.setContentIntent(pending);
  builder.setAutoCancel(true);
  Notification notification = builder.build();
  NotificationManager manager = ...;
  manager.notify(88,notification);
  
#+END_SRC
* Toast
** 拥有自定义布局的 toast
#+BEGIN_SRC java
  Toast toast = new Toast(this);
  View view = getLayoutInflater().inflate(R.layout.xxx,null);
  toast.setView(view);
  toast.setGravity(Gravity.CENTER,0,0);
  toast.setDuration(Toast.LENGTH_SHORT);
  toast.show();
#+END_SRC


* <<Adapter>> 适配器
** ArrayAdapter
一般步骤
1. 创建一个 ArrayAdapter 对象,放入参数
2. 找到需要添加适配器的控件 id
3. 使用 setAdapter()方法添加适配器
** <<BaseAdapter>>
ArrayAdapter 中只能添加 TextView ，对于自定义列表来说尚有不足，
所以使用 BaseAdapter 来自定义

继承自 BaseAdapter 的类需要实现的方法有
| method                                                                | disription             |
|-----------------------------------------------------------------------+------------------------|
| public int getCount()                                                 | 返回 list 的个数       |
| public Object getItem(int position)                                   | 返回 list.get(position) |
| public long getItemId(int position                                    | 返回 position          |
| public View getView(int position, View convertView, ViewGroup parent) |                        |

: 重点解释最后一个

更新一下防止图片错位的方法，主要是为View添加一个url（图片下载路径），记录一下代码
#+BEGIN_SRC java
@Override
    public View getView(int position, View convertView,final ViewGroup parent) {
        //转化为view控件，并返回
        ViewHolder viewHolder = null;
        if(convertView == null){
            convertView = LayoutInflater.from(context).inflate(R.layout.item_data,null);
            viewHolder = new ViewHolder();
            viewHolder.titleTv = (TextView) convertView.findViewById(R.id.titleId);
            viewHolder.infoTv = (TextView) convertView.findViewById(R.id.infoId);
            viewHolder.coverImgView = (ImageView) convertView.findViewById(R.id.coverId);
            //view 的tag
            convertView.setTag(viewHolder);
        }else{
            //获得 view 的 tag
            viewHolder = (ViewHolder) convertView.getTag();
            //重置图片的内容
            viewHolder.coverImgView.setImageResource(R.drawable.ic_launcher);
        }
        //设置显示内容
        viewHolder.titleTv.setText(datas.get(position).getTitle());
        viewHolder.infoTv.setText(datas.get(position).getInfo());

        String imaPath = datas.get(position).getWap_thumb();
        //给 ImageView 添加 tag
        viewHolder.coverImgView.setTag(imaPath);
        if (imaPath != null){
            if(imaPath.length()>10){
                //存在图片路径
                viewHolder.coverImgView.setVisibility(View.VISIBLE);
                //先从SD卡读取，在下载
                final Bitmap bitmap = ImageUtils.getImg(imaPath);
                if(bitmap!=null){
                    viewHolder.coverImgView.setImageBitmap(bitmap);
                }else{
                    NUtils.get(NUtils.TYPE_IMG,imaPath, new NUtils.Callback() {
                        @Override
                        public boolean isCancelled(String url) {
                            return parent.findViewWithTag(url)==null;
                        }
                        @Override
                        public void response(String url, byte[] bytes) throws UnsupportedEncodingException, JSONException {
                            ImageView imageView = (ImageView) parent.findViewWithTag(url);
                            if(imageView != null){
                                imageView.setImageBitmap(BitmapFactory.decodeByteArray(bytes,0,bytes.length));
                            }
                        }
                    });
                }
            }else{
                viewHolder.coverImgView.setVisibility(View.GONE);
            }
        }else{
            viewHolder.coverImgView.setVisibility(View.GONE);
        }
        return convertView;
}
#+END_SRC
#+BEGIN_QUOTE
PS: 分页需要一个List用来存放数据，并且需要服务端提供分页的接口
#+END_QUOTE
** SimpleAdapter
一个简单的自定义适配器
*** 构造方法的参数 Context，list<Map>，布局文件，from，to
: from：Map中的键 
: to: 相应填充控件的id
** SimpleCursorAdapter
内部使用 CursorLoader 查询的 Adapter

构造方法
: SimpleCursorAdapter(Context context, int layout, Cursor c, String[] from, int[] to, int flags)

小例子
#+BEGIN_SRC java
//获取扩展卡下所有音频文件
private Uri mp3Uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
private String[] columns = {MediaStore.Audio.Media._ID,
        MediaStore.Audio.Media.DISPLAY_NAME,
        MediaStore.Audio.Media.DATA,
        MediaStore.Audio.Media.DURATION};

SimpleCursorAdapter cursorAdapter = new SimpleCursorAdapter(getApplicationContext(),R.layout.item_audio,null,
                                     new String[]{columns[1],columns[2],columns[3]},
                                     new int[]{R.id.textNameId,R.id.textPathId,R.id.textDurationId},
                                     SimpleCursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER);
listview.setAdapter(cursorAdapter);
#+END_SRC
** 重构适配器
#+BEGIN_SRC java
public abstract class AbsAdapter<T> extends BaseAdapter {

    private Context context; //上下文对象
    private int layoutResId; //item布局资源
    private List<T> datas; //数据源

    public AbsAdapter(Context context, int layoutResId, List<T> datas) {
        this.context = context;
        this.layoutResId = layoutResId;
        this.datas = datas;
    }

    @Override
    public int getCount() {
        return datas.size();
    }

    @Override
    public Object getItem(int position) {
        return datas.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder vHolder=null;
        if(convertView==null){
            convertView= LayoutInflater.from(context).inflate(layoutResId, parent,false);
            vHolder=new ViewHolder(convertView);

            convertView.setTag(vHolder);
        }else{
            vHolder=(ViewHolder) convertView.getTag();
        }

        bindView(vHolder,datas.get(position)); //将数据显示到item布局中

        return convertView;
    }

    public abstract void bindView(ViewHolder vHolder,T data);

    public static class ViewHolder{
        private Map<Integer,View> cacheViews;
        private View itemView;

        public ViewHolder(View itemView){
            this.itemView=itemView;
            cacheViews=new HashMap<Integer,View>();
        }

        public View getView(int id){ //查找指定id的item中子控件
            View v=cacheViews.get(id);
            if(v==null){
                v=itemView.findViewById(id);
                if(v!=null){
                    cacheViews.put(id, v);
                }
            }

            return v;
        }
    }

}
#+END_SRC
* 数据存储
** 使用 adb 查看App内的文件
知晓adb 的命令
** 内部存储
以文件的形式存储数据， IO 流
*** 存数据
#+BEGIN_SRC java
  String filename = "filename";
  String fileContent = "fileContent";
  FileOutputStream fos = openFileOutput(filename,Context.MODE_PRIVATE);
  fos.write(fileContent.getBytes());
  fos.close();
#+END_SRC
*** 读数据
#+BEGIN_SRC java
  String filename = "filenameToRead";
  
  FileInputStream fis = openFileInput(filename);
  byte[] arr = new byte[fis.available()];
  int len = fis.read(arr);
  //再将内容写入到需要写入的 View 中。
#+END_SRC

*** 内部控件所有文件名

** 外部存储
判断扩展卡是否挂载

*** 扩展卡中文件操作的[[工具类]]




 
** <<数据库存储>>
在创建数据库的实体类后，
#+BEGIN_SRC java
  //数据库操作类 SQLiteDatabase

  public staic final String DB_PATH = Environment.getExternalStorageDirectory()+"/file/db/xx.db";
  
  //打开数据库 参数： 路径 ， 管理游标工厂 ， 操作数据库的模式
  SQLiteDatabase db = SQLiteDatabase.openDatabase(DB_PATH,null,SQLiteDatabase.OPEN_READONLYWRITE);
  
  //查询表中的数据,数据放于 Cursor
  Cursor cursor  = db.rawQuery("select * from student",null);
  //从 Cursor 中获取记录
  while(cursor.moveToNext()){
      //使用游标记录中每个字段上的值 认为_id 就是一个字段
      int id = cursor.getInt(cursor.getColumnIndex("_id"));
      //将结果放入实体类中
      Object o = new Object(id);
      //需要放入集合中再放入集合
      list.add(o);
  }
  
  //增加
  db.execSQL("insert into tablename values(?,?,?,?,?)",new Object[]{4,"ll","nan",44,4443103});
  
  //or
    
  ContentValue values = new ContentValue();
  values.put("_id",5);
  long num = db.insert("student,null,values");
  if(num != -1)
  //添加成功
    
  //修改
  db.execSQL("update tablename set age=?,_id=?   where _id=?",new Objext[]{45,_id});
  db.update();
  //删除
  db.execSQL("delete from student where _id=?", new Objext[]{});
  db.delete("student","_id="+id,null);
  
  //随后重新查询; 
  
  
  db.close();
  
#+END_SRC

#+BEGIN_SRC java
  //数据库管理类 SQLiteOpenHelper
  DBHelper extends SQLiteOpenHelper{
      public DBHelper(Context context){
          //name 就是数据库名字，游标取 null，版本 1.
          super(context,name,factory,version);
      }
      public void onCreate(SQLiteDatabase db){
          db.execSQL("create table t_user(_id integer primary key,name text)");
      }
      public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
          if(newVersion>oldVersion){
              db.execSQL("drop table if exists t_user");
          }
      }
  }
#+END_SRC
** 共享参数 SharedPreferences 
*** 存数据
#+BEGIN_SRC java
  //共享参数文件的名字，对该文件的操作模式
  SharedPerferences shared = getSharePreference("configration",Context.MODE_PRIVATE);//MODE.xxx
  SHaredPerferences.Editor edit = shared.edit();
  edit.putInt(key,value);
  edit.commit();
#+END_SRC
*** 读数据
#+BEGIN_SRC java
  sharedPerferences shared = getSharePreference("configration",Context.MODE_PRIVATE);
  int i = shared.getFloat("key",value);//不存在key对应的值时使用第二个值
#+END_SRC

* <<Fragment>>
可以当成 Activity 使用，但是 Fragment 是显示在 Activity 中的。
** 如何开始
新建一个继承 Fragment 的子类，重写 onCreateView 方法
#+BEGIN_SRC java
  public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
      TextView textView = new TextView(getActivity());
      textView.setWidth(50);
      textView.setHeight(50);
      textView.setTextSize(20sp);
      textView.setText("fragment");
      return textView;
  }
#+END_SRC
或者为 Fragment 设置一个布局，可以直接 return inflater.inflate(R.layout.name,null)
** 将 Fragment 显示到 Activity 上的两种方式
*** 静态方式
在 Activity 的布局文件中加入 fragment 标签，并在name中添加 Fragment 的包名+类名.
*** 动态方式
动态显示 fragment 需要定义一个布局，用来放置 fragment .
可以使用容器视图来放置。

随后在 Activity 中得到
#+BEGIN_SRC java
  FragmentManager manager = getFragmentManager(); 
  FragmentTransaction transaction = manager.beginTransaction();
  //第二个参数是继承 Fragment 的子类
  transaction.add(R.id.id,new Fragment());
  transaction.replace(R.id.id,fragment);  
  transaction.commit();  
#+END_SRC

** 基本用法
*** 在 Activity 中获取 Fragment 的内容
使用 FragmentManager 来管理 Fragment 

MainActivity.java
#+BEGIN_SRC java
  FragmentManager manager = getFragmentManager();
  Fragment fragment = manager.findFragmentById(R.id.id);
  View view = fragment.getView();
  TextView textview = (TextView)view.findFragmentById(R.id.viewid);
  //随后可以动态或静态显示到 Activity 上
  FragmentManager manager = getFragmentManager(); 
    
  FragmentTransaction transaction = manager.beginTransaction();
  //第二个参数是继承 Fragment 的子类
  transaction.add(R.id.id,new Fragment());
  
  //Activity给 Fragment 传参数
  Bundle bundle = new Bundle();
  bundle.putString("msg","hehe"+new Data());
  fragment.setArguments(bundle);
  //随后在 Fragment 类中得到参数
  
  transaction.replace(R.id.id,fragment);
    
  Transaction.commit();
#+END_SRC

*** Fragment 回传给 Activity 的值
在 [[接口回调]] 中说过

** 生命周期方法
| return | method_name        | 用途                               |
|--------+--------------------+------------------------------------|
| void   | onAttach(Activity) | 和 Activity 关联                   |
| void   | onCreate(Bundle)   | Fragment 初始化                    |
| View   | onCreateView()     | 初始化 UI 视图                     |
| void   | onActiviyCreated() | Activity 的 onCreate()执行完，就执行 |
|        |                    |                                    |
| void   | onStart()          |                                    |
| void   | onResume()         |                                    |
| void   | onPause()          |                                    |
| void   | onStop()           |                                    |
|        |                    |                                    |
| void   | onDestroyView()    | 销毁 UI 视图                       |
| void   | onDestroy()        | 销毁 fragment                      |
| void   | onDettach()        | 和所属的 Activity 失联             |


** 实现类似回退栈的功能
利用事务中的 addToBackStack(null); 方法加入事务栈，

onBackPressed();方法回滚事务

** DialogFragment
子类独有的方法
: onCreateDialog();//用来返回一个对话框对象

: onCreateView();//返回一个对话框

** ListFragment
自身带有 ListView 即 Oncreateview() 返回的就是一个带有 ListView 的布局
对象.所以 listView 在 Oncreateview 后绑定数据或适配器
设置适配器使用 setListAdapter(),并且已经实现了事件监听，如果需要添加事件监听需要重写相应方法

事件监听方法: onListItemClick(...);

分析
- listView 放置在 Fragment 中
- 点击 listView 会出现一个 Activity，显示内容
- 考虑到文件内容较多， 使用一个 ScrollView 
具体实现:
*** FilesFragment 继承 Fragment
利用布局打气筒生成 Xml 文件的布局

获取 ListView 的 id

要显示的内容就是 String，使用 ArrayAdapter

listView 实现点击监听事件， 利用 Bundle 传出文件名

合理放置在各个生命周期中
*** 静态显示 FilesFragment
添加一个 fragment 标签
*** 打开后的 Activity 以及 其中的 Fragment 
其中放置一个 Fragment ， 再放置存放文件内容的 textview Id，
并且获取上一个 Activity 传来的值。

利用 AssetManager manager = getResources().getAssets();
和 IO 流来获取文件内容

*** 如果要添加横屏时的布局文件 
添加文件夹 layout-land 在其中设置横屏的xml文件，将要显示的内容
添加在另一个 fragment 中，在点击事件中判断屏幕方向
: if(getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDS...
如果横屏，动态加载 fragment 


*** 添加一个静态方法用来快速返回一个 Fragment
使用静态方法快速将 Bundle 传递给 Fragment 并返回一个实例
#+BEGIN_SRC java
public static  DataFragment newsInstance(String url){
        DataFragment f = new DataFragment();
        Bundle bundle = new Bundle();
        bundle.putString("url",url);
        f.setArguments(bundle);
        return f;
}
#+END_SRC
ListFragment 自带 ListView， 为了实现数据显示，还需要 一个[[BaseAdapter][适配器]]和存放数据的容器。

** 一个简单的使用方法例子
#+BEGIN_SRC java
private void abcd(String tag, Class<? extends Fragment> cls) {
        Fragment f;
        f = fragmentManager.findFragmentByTag(tag);
        if (f == null) {
//            f = new Model1MenuFragment();
            try {
                f = cls.newInstance();
                if (currentFragment == null) {
                    //第一个页面
                    fragmentManager.beginTransaction()
                            .add(R.id.leftMenuContainerId, f, tag)//model1 就是 tag
                            .commit();
                } else {
                    //隐藏当前正显示的 fragment 并添加第一次显示的model1 碎片
                    fragmentManager.beginTransaction()
                            .hide(currentFragment)
                            .add(R.id.leftMenuContainerId, f, tag)
                            .commit();
                }
            } catch (InstantiationException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }

        } else {//之前已经显示过，再次显示
            if (currentFragment == f) {
                return;
            }
            fragmentManager.beginTransaction()
                    .hide(currentFragment)
                    .show(f)
                    .commit();
        }
        currentFragment = f;
    }
#+END_SRC
* Loaders 
Loaders 令异步读取数据变得简单, Loaders 的一个特点就是可以在配置改变时重连.
** Loader API Summary
| Class/Interface               | Description                                      |
|-------------------------------+--------------------------------------------------|
| LoaderManager                 | 用来管理 Loader                                  |
| LoaderManager.LoaderCallbacks | 一个 LoaderManager 的接口回调                    |
| Loader                        | 一个抽象父类                                     |
| AsyncTaskLoader               | 提供一个 AsyncTask 的抽象类                      |
| CursorLoader                  | 用来查询数据库的实用子类，继承自 AsyncTaskLoader |
|-------------------------------+--------------------------------------------------|
|                               |                                                  |
** 在 Application 中使用 Loader
在一个应用中实用 Loader 一般需要如下:
- 一个 Activity 或 Fragment
- 一个 LoaderManager 的实例
- 一个 实现的子类（比如 CursorLoader 用来查询数据库，或者自定义的 Loader 用来做自定义的事情）
- 实现 LoaderManager.LoaderCallbacks ， 在这里创建新 Loader 和 管理引用指向已存在的 Loader
- 一个存放数据的地方， 比如一个 SimpleCursorAdapter
- 一个数据源， 比如 ContentProvider

*** 开始一个 Loader
LoaderManager 用来管理一个或多个 Loader 实例，所以 LoaderManager 只需要一个， Loader 可以有多个。

可以在 Activity 的 onCreate() 方法或者 在 Fragment 的 onActivityCreated() 方法来初始化一个 Loader
: getLoaderManager().initLoader(0, null, this);
- 第一个参数是一个唯一的ID
- Optional arguments to supply to the loader at construction (null in this example).
- 一个 LoaderManager.LoaderCallbacks 的实现
#+BEGIN_QUOTE
注意：
#+END_QUOTE
- 如果ID重复了，新的 Loader 会覆盖旧的
- 如果ID不存在， 调用 LoaderManager.LoaderCallbacks 回调接口的 onCreateLoader() 方法返回一个新的 Loader

*** 重新加载 Loader
在初始化一个 Loader 后，如果数据需要更新，可以使用 restartLoader() 来更新数据.

*** 使用回调接口 LoaderManager.LoaderCallbacks 
使用 LoaderManager.LoaderCallbacks 回调接口用来管理什么时候创建，停止，重启 Loader，所以它具有一下方法
- onCreateLoader()--利用拿到的 ID 初始化并返回一个新的 Loader
- onLoadFinished()--上一个 Loader 加载结束的时候调用
- onLoaderReset()-- 上一个 Loader 需要重置的时候调用


**** onCreateLoader
当一个 Loader 被初始化时，调用这个方法，并判断 ID 是否重复。
该方法接受以下参数
- uri--需要检索的URI
- projection--返回的行的集合
- selection--返回行中哪些列的数据
- selectionArgs--上一个参数中的 ? 在这里用 String 数组定义
- sortOrder--***

**** onLoadFinished
在这个方法中将加载好的数据与 SimpleCursorAdapter 进行交换，使用
: simplecursoradapter.swapCursor(data);

**** onLoaderReset
这个方法在 Loader 不需要的时候调用，需要将 Simplecursoradapter 的数据用null 替换掉
: simplecursoradapter.swapCursor(null);
** TODO CursorLoader
* Handler
线程之间发送消息.

使用异步任务的原因
- 主线程不能执行耗时操作
- 子线程不能操作UI线程的UI视图
Handler 的核心类
- Message :: 对发送的消息的封装
- MessageQueue :: 消息队列，存放所有的消息
- Looper :: 循环读取消息（从 MessageQueue 中读取）
- Handler :: 处理消息，发送消息

** TODO Handler 过程解释 
** 子线程给主线程发消息
Handler 定义在主线程。主线程需要循环读取 MessageQueue，具备读取功能的是 Lopper
而主线程中已经定义了 Lopper 对象，所以不需要自己定义。

: 结论：只需要在主线程中定义 Handler.
*** 下载图片
子线程下载图片，完成后发送消息给主线程

发送方式有两种
1. 使用 sendMessage(Message msg) 发送， 使用handlerMessage(Message mag)处理
2. 使用 post(Runnable r) 发送， 直接发送的是主线程需要执行的代码.
#+BEGIN_SRC java
    public static final String path = "";
    private Handler handler = new Handler(){
            @Override
            public void handlerMessage(Message msg){
                //处理子线程发送过来的 Message
                Bitmap bitmap = (Bitmap)msg.obj;
                //交给主线程UI处理 设置到 ImageView 什么的              
            }
        }
    public void downImage(View view){
        new Thread(new Runnable()){
                public void run(){
                    HttpGet get = new HttpGet(path);
                    HttpClient client = new DefaultHttpClient();
                    HttpResponse response = null;
                    response = client.execute(get);
                    if(response.getStatusLine().getStatusCode == 200){
                        byte[] arr = EntityUtils.toByteArray(response.getEntity());
                        Bitmap bitmao = BitmapFactory.decodeByteArray(arr,0,arr.length);
                        //下载完成时，把图片发送给主线程
                        //从 MessageQueue 中获取可用的 Message 对象，如果没有可用的则创建一个新的 Message 对象
                        Message msg = Message.obtain();
                        //发送的图片封装到 msg 中
                        msg.obj = bitmap;
                        //使用 Handler 发送 msg
                        handler.sendMessage(msg);  
                        //post 方式
                        handler.post(new Runnable()){
                            run(){
                                //将此任务发给UI线程取执行，将图片显示在UI上
                            }
                        }
                    }
                }
            }
  }
#+END_SRC


*** 计时器
** 主线程给子线程发送消息

#+BEGIN_SRC java
  MainActivity{
      Handler handler ;
      public void sendMessage(View view){
          Message msg = Mseeage.obtain();
          msg.obj = "hello,thread";
          handler.sendMessage(msg);
      }
  
      //创建子线程
      class MyThread extends Thread{
          public void run(){
              //首先要有 Looper 对象
              Lopper.prepare();//创建一个 Lopper 对象，并把它放到线程本地变量中
              //在子线程中实例化 handler
              handler = new Handler();//如果直接实例化会出现 RuntimeException ，原因是子线程没有 Looper 对象
              //让 Looper 对象循环读取 message 
              Looper.loop();
              
          }
      }
  }
  
#+END_SRC
* <<异步任务>>
在主线程执行的操作超过5s，就认为是耗时操作，程序出现 ANR:Application Not Response.
改进方法:让子线程去执行耗时操作.

但是:子线程无法修改UI线程中的视图，所以需要子线程通知主线程，
为了实现线程间的通信,就需要使用异步任务。

** <<AsyncTask>>
异步任务类本身具备创建子线程的功能.
继承 AsyncTask<String,Void,String>类，

泛型解释
1. doInBackground 方法需要接受的参数的类型
2. 显示进度时的类型 Integer
3. doInBackground 方法返回值的类型
  
重写 doInBackground()方法，将耗时操作写在其中

void onPostExecute(String result);result 就是 doInBackground 方法的返回值
此方法执行在UI线程中,改变UI.

在UI线程中调用 AsyncTask.execute()方法执行

添加对话框
#+BEGIN_SRC java
void onPreExecute(){
    dialog.show();
}
#+END_SRC

: onProgessUpdate，在调用 publishProgress 后调用。

** 常用的异步任务
*** 异步下载
: task
#+BEGIN_SRC java
  public class DownloadPicAsyncTask extends AsyncTask<String,Void,Bitmap> {
      private Bitmap bitmap;
      private OnFinishBitmapListener onFinishBitmapListener;
  
      public void setOnFinishBitmapListener(OnFinishBitmaoListener onFinishBitmapListener) {
          this.onFinishBitmapListener = onFinishBitmapListener;
      }
  
      public DownloadPicAsyncTask(Bitmap bitmap) {
          this.bitmap = bitmap;
      }
      @Override
      protected Bitmap doInBackground(String... params) {
          InputStream inputStream = null;
  
          byte[] bytes = null;
          try {
              inputStream = HttpUtil.getInputStream(params[0]);
              bytes = HttpUtil.InputStream2byte(inputStream);
  
          } catch (IOException e) {
              e.printStackTrace();
          }
          bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
          return bitmap;
      }
  
      @Override
      protected void onPostExecute(Bitmap bitmap) {
          super.onPostExecute(bitmap);
          onFinishBitmapListener.onFinishBitmap(bitmap);
      }
  }

#+END_SRC
: interface
#+BEGIN_SRC java
public interface OnFinishBitmapListener {
    public void onFinishBitmap(Bitmap bitmap);
}

#+END_SRC
** Loader
是异步任务的封装，实现异步加载。包名+自定义权限名
1. 让 Activity 或 Fragment 实现 LoaderCallbacks
2. 实现回调方法

#+BEGIN_SRC java
  //初始化并启动
  public onCreate(){
      getLoaderManager().initLoader(1,null,this);  
  }
  
  
#+END_SRC

* <<Intent>>意图
** Intent 的七大属性
1. 显示跳转
2. Action
   1. 进入到打电话界面 ACTION_DIAL
   2. 直接呼叫 ACTION_CALL
   3. 向其发送短信 SENDTO
3. Gategory
   1. CATEGORY_DEFAULT 默认模式
   2. CATEGORY_HOME  HOME界面
   3. CATEGORY_BROWSABLE 浏览器界面
4. Data
5. Type
6. Extra
7. Flag

** 生命周期
1. 运行状态,位于最前端,可以与用户交互
2. 停止状态,完全被其他界面覆盖,但是状态信息和数据还保留.内存不足时被销毁
3. 暂停状态:部分被覆盖.
4. 销毁状态,人为的销毁,系统销毁.
一个 Activity 从被创建到被销毁执行的生命周期方法


* <<Action Bar>>
** 简单介绍
*** 隐藏,显示 Action Bar
隐藏
#+BEGIN_SRC java
getActionBar().hide();
#+END_SRC
显示
#+BEGIN_SRC java
getActionBar().show();
#+END_SRC
*** Action Bar 主要在资源文件中添加内容
修改 menu 的 showAsAction 属性，建议 "ifRoom|withText"
意义就是如果有控件就显示，并且带文字。

各种按钮在 menu 中添加
*** 设置点击事件
#+BEGIN_SRC java
onOptionsItemSelected(MenuItem item){
    switch(item.getItemId()){
    case R.id.a:
        //系统时间
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss SSS");
        textview.append(sdf.format(new Date()));
        break;
    case R.id.b:
        //拨号 权限 CALL
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss SSS");
        textview.append(sdf.format(new Date()));
        startActivity(new Intent(Intetn.ACTION_CALL,Uri.parse("tel:10086")));
        break;
    }
}
#+END_SRC
*** 分离
在 配置文件中的 Activity 中加入 uiOption 属性

当屏幕宽度空间不足时，会分割 ActionBar
*** 设置 Logo 图标可点击
在 Activity 中调用以下方法
#+BEGIN_SRC java
getActionBar().setDisplayShowHomeEnable(true);
getActionBar().setDisplayHomeAsUpRnable(true);
#+END_SRC
监听ID : R.id.home 就可以监听该事件
*** 设置属性的例子



** Tab
要熟练掌握.针对API 版本较高时 ActionBar 消失的问题， 将 values 下的 styles 中的主题设置为 android:Theme.Holo.Light.DarkActionBar ， 并且 MainActivity 继承 Activity .
*** 基本歩骤
1. 在 onCreate 方法中 使用 getActionBar() 方法得到一个 ActionBar
2. 设置模式 actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
3. Activity 承继 ActionBar.TabListener并 实现三个方法
   - public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft)
   - public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft)
   - public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft)
4. 为 ActionBar 设置属性

#+BEGIN_QUOTE
3中主要实现第一个方法就行，并且参数中自带 FragmentTransaction ，由于是系统创建的不需要 commit(); 仅把 fragment 放置到其中即可
#+END_QUOTE
一个将 NewsInfoFragment (新闻有关的Fragment) 放置到其中的例子
#+BEGIN_SRC java
@Override
public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
        int cateid = newsCategoryList.get(tab.getPosition()).getId();
        Log.d("newid","====="+cateid);
        fragment = NewsInfoFragment.newIntance(cateid);
        ft.replace(R.id.framelayout, fragment);
    }
#+END_SRC

4中的示例代码，将分好类的 News 设置为 Tab 的Text，并且设置监听.
#+BEGIN_SRC java
for(NewsCategory newsCategory : newsCategoryList){
            actionBar.addTab(actionBar.newTab()
                    .setText(newsCategory.getName())
                    .setTabListener(this));
        }
#+END_SRC
* ViewPager
** 概述
ViewPager 中需要一个适配器（FragmentPagerAdapter）,继承 FragmentPagerAdapter 需要这样
#+BEGIN_SRC java
class DataFragmentAdapter extends FragmentPagerAdapter {

        public DataFragmentAdapter(FragmentManager fm){
            super(fm);
        }
        @Override
        public Fragment getItem(int position) {
            return fragments.get(position);
        }

        @Override
        public int getCount() {
            return fragments.size();
        }
}
#+END_SRC
其中的 fragments 是存放 fragment 的容器。 将滑动的 Fragment 放入其中。

再为各个 fragment 添加 tab，利用 [[Action Bar]] 里的知识，添加各个 fragment 的标题。

实现点击 tab 后跳转到相应的 fragment 
#+BEGIN_SRC java
@Override
    public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
        viewPager.setCurrentItem(tab.getPosition());
    }
#+END_SRC
这样ViewPager 和 ActionBar的 tab 就结合到了一起。

** ViewPager+v7包 歩骤
1. 导入v7包下的 appcompat 类库工程，勾选复制到工作空间中
2. 项目中引入 v7 包下的工程，作为依赖库使用
3. 修改 Activity 主题样式
4. 修改继承的 Activity 类为 ActionBarActivity
5. 在 Activity 类中，通过 getSupoortActionBar() 获取
另：
- 如果使用 SearchView 
  1. 在资源文件中导入v7的命名空间 xmlns:app="...apk/res-auto"
  2. android:showAsAction改为v7中的属性，即app:showAsAction.
  3. android:actionViewClass改为app:actionViewClass

file:/home/alex/Pictures/V7下的SearchView获得方法.png


* 四大组件
** Activity
*** 如何新建一个页面
1. 新建一个 Activity 类
2. 在清单文件中注册
*** 从一个界面启动另一个界面
#+BEGIN_SRC java
Intend intend = new Intent(this,activityName.class);
startActivity(intent);
#+END_SRC
[[Intent][查看Intent内容]]
*** Activity 之间的传值

1.使用 Intent 传值,如果传递对象,必须是可序列化的.
#+BEGIN_SRC java
Intent intent = new Intetn(this,activityName.class)'
intent.putExtra("key","value");
startActivity(intent);
#+END_SRC

被启动的 Activity 首先获得 Intent 对象
#+BEGIN_SRC java
Intent intent = getIntent();
Value value = intent.getStringExtra("key");
#+END_SRC

2.也可以使用 Bundle 传值,先把数据存入 Bundle,再将 Bundle 放入 Intetn 中.

3.使用 Application 来传递,需要继承 Application,并修改清单文件使创建继承后的 Application,
然后就可以向下转型成继承后的 Application.
#+BEGIN_SRC java
Intent intent = new Intent(this,activityName.class);
Application app = getApplication();
#+END_SRC
4.如何得到启动的 Activity 返回的数据
A中开启B时使用 startActivityForResult(intent,requestCode);

B返回数据,new 一个 Intent,调用 putExtra(key,value);再调用
setResult(resultCode,intent);

A覆写 onActivityResult(int requestCode,int resultCode, Intent data),得到返回的数值
之前判断请求码和结果码,最后获得intent中的数据.

Activityname

*** 隐式意图
#+BEGIN_SRC java
  //打开系统设置
  startActivity(new Intent(Settings.ACTION_SETTINGS));
#+END_SRC

** <<ContentProvider>>内容提供者
App 提供一个接口令外部 App 能够访问私有数据，需要使用 ContentProvider 
而外部的 App 利用 ContentResolver 来访问 ContentProvider 提供
的内容。

*** URI 格式
: schema://host:port/path
比如通话记录的 URI 就是 CallLog.Calls.CONTENT_URI
*** 权限
: READ_CALL_LOG 访问通话记录
*** 访问 ContentReslover
**** 使用
 
#+BEGIN_SRC java
  private Uri callUri = CallLog.Calls.CONTENT_URI;
  private String[] columns = {CallLog.Calls._ID,
                              CallLog.Calls.NUMBER,
                              CallLog.Calls.DATE,
                              CallLog.Calls.TYPE};
  
  private void loadData(){
      //访问拨号记录应用下的数据
      //得到 ContentResolver 对象
      ContentResolver reslover = getContentResolver();
      //查询 URI 代表的资源
      Cursor cursor = reslover.query(CallUri,columns,null,null,null);
      while(cursor.moveToNext()){
          long id = cursor.getLong(0);
          String number = cursor.getString(1);
          long time = cursor.getLong(2);
          //转时间
          String date = new SimpleDateFormat("YYYY-MM-dd E HH:mm:ss").format(new Date(time));
          //1:拨入 2:拨出 3:未接
          int type = cursor.getInt(3);
          //定义一个存放信息的实体类 CallInfo
          CallInfo callinfo = new Callinfo(id,number,date,type);
      }
  
  }
  
#+END_SRC
**** 实现联系人的增删改查
***** 联系人的数据库
联系人信息表
: raw_contacts(_id,display_name,display_name_alt)
联系人数据表
: data(_id,raw_contact_id(外键),data1,data2,mimetype_id(数据类型))
数据类型表
: mimetypes(_id,mimetype)

SQL

from raw_contacts t1 join data t2 on (t1._id=t2.raw_contact_id)
where t2.mimetype_id=5;

***** 代码
显示和增加 
#+BEGIN_SRC java
  private Uri contactsUri = Uri.parse("content://com.android.contacts/raw_contacts");
  private String[] conColumn = {"_id","display_name"};
  
  private Uri dataUri = Uri.parse("content://com.android.contacts/data");
  private String[] conColumn = {"data1"};
  ContentResolver reslover = getContentResolver();
  
  public void showContacts(View v){
      datasUri.clear();
      //先从联系人表中查询人的信息
      Cursor cursor = resolver.query(contactsUri,conColumn,null,null,null);
      while(cursor.moveToNext()){
          long id = cursor.getLong(0);
          String name = cursor.getString(1);
          //根据id查询详细信息
          Cursor phoneCursor = getContentResolver().query(dataUri,dataColumn,"mimetype_id=5 and raw_contact_id="+id,null,null);
  
          if(phoneCursor.moveToNext()){
              String phone = phoneCursor.getString(0);
          }
          //将数据加入Map或实体类
  
      }
  }
  public void addContacts(View v){
      //先设置一个对话框 在对话框的点击事件中
      public void onClick(){
          ContentValues values = new ContentValues();
          values.put("display_name",name);
          values.put("display_name_alt"name);
          //返回插入记录的 Uri ，并在其中包含id
          Uri datasUri = getContentResolver().insert(contactUri,values);
          //从 Uri 获取id
          long _id = ContentUris.parseId(datasUri);
          //向数据表中插入姓名，电话，邮箱
          values.clear();
          values.put("raw_contact_id",_id);
          values.put("data1",name);
          values.put("mimetype","vnd.android.cursor.item/name");
          getContentResolver().insert(dataUri,values);
  
          values.put("data1",phone);
          values.put("mimetype","vnd.android.cursor.item/phone_v2");
          getContentResolver().insert(dataUri,values);
  
          values.put("data1",email);
          values.put("mimetype","vnd.android.cursor.item/email_v2");
          getContentResolver().insert(dataUri,values);
          //重新查询数据库
          showContacts(null);
      }
  }
#+END_SRC
[[Dialog]]

删除，修改。前提：实现长按数据项出现上下文菜单，可选择修改和删除
#+BEGIN_SRC java
    
  //更新联系人信息
  ContentValues value = new Values();
  value.put("display_name",name);
  value.put("display_name_alt",name);
  
  getContentResolver().update(contactUri,value,"_id="+id,null);
  //更新数据表中联系人的姓名
  value.put("data1",name);
  value.put("raw_contact_id",value);
  getContentResolver().update(dataUri,value,"mimetype_id=7 and raw_contact_id="+id,null);
  
  //删除,从数据表中删除信息
  getContentResolver().delete(dataUri,"raw_contact_id="+id,null);
  //联系人表中对应的也删掉
  getContentResolver().delete(contactUri,"_id="+id,null);
#+END_SRC
[[上下文菜单]]

*** 自定义 ContentProvider
首先定义了[[数据库存储][数据库]]后，定义一个类继承 ContetnProvider 

并在清单文件注册
#+BEGIN_SRC xml
  <provider
  android:name="包名+UserContProvider"
  android:authorities="包名+标识名"
  android:permission="自定义的权限"
  android:exported="true"
  />
  <permission android:name="包名+自定义权限名比如：all"/>
  <uses-perssion android:name="包名+自定义权限名"/>
#+END_SRC

#+BEGIN_SRC java
  //定义一个唯一标识，通常使用包名+数据库名
  public static final String AUTHORITY = "com.qianfeng.user";
  //可以被外界访问的数据库资源的 Code 标识
  public static final int CODE_USER = 1;
  //访问资源的 Uri 的匹配器对象
  public static final int CODE_ORDER = 8;
  private UriMatcher uriMatcher; 
  static {
      uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
      //表名为 user 的Uri资源
      uriMatcher.addURI(AUTHORITY,"user",CODE_USER);
      uriMatcher.addURI(AUTHORITY,"order",CODE_ORDER);
  }
  
  public static onCreate(){
      dhHelper = new DBHelper(getContext());
      return false;
  }
  
  public Cursor query(Uri uri,String[] projection, String selection,String[] selectionsArgs, String sirtOrder){
      SQLiteDatabase db = dbHeloer.getReadbaleDatabase();
      Cuesor cuesor = null;
      int code =  uriMatcher.match(uri);
      switch(code){
      case CODE_USER:
          curder = db.query("t_user",projection,selection,selectionArgs,null,null,sortOrder);
          break;
      case CODE_ORDER:
          break;
  
          return cursor;
      }
  }
  public Uri insert(Uri uri, ContentValues values){
      SQLiteDatabase db = dbHeloer.getWritableDatabase();
      if(uriMatcher.match(uri) == COE_USER){
          long id = db.insert("t_user",null,values);
          //返回新插入的记录的uri
          return ContentUris.withAppendedId(uri,id);
      }  
  }
  public int delete(uri,selection,selectionArgs){
      
  }
#+END_SRC
** Service
*** startService 管理 Service 的用法
1. 创建Service子类，重写三个核心的生命周期方法和一个抽象方法
   1. OnCreate()
    : 在线程启动时调用，再调用则调用 onStartCommand() 方法
   2. onStartCommand()
   3. onDestroy()
   4. onBind()
 
2. 配置文件中注册Service组件
 : <service android:name=".PlayerService"/>
3. 启动和停止Service
 : startService(intent);
 : stopService(intent);

*** MediaPlayer
使用过的方法一览
| Method Name          | Discriable                            |
|----------------------+---------------------------------------|
| getCurrentPosition() | 得到当前播放到的毫秒数                |
| getDuration          | 得到总的毫秒数                 |
| isPlaying()          | 是否在播放                       |
| pause()              | 暂停                                |
| prepare()            | 准备后可以执行 开始          |
| prepareAsync ()      | 使用异步任务的 prepare()       |
| reset()              | 重置到空状态，需要 prepare() 才能开始 |
| seekTo(int current)  | 进度走到 current 的位置，单位是 ms |
| start()              | 开始                                |
| stop()               | 停止                                  |


*** BindService
将 Activity 和 Service 绑定

相比普通的 Service， BindService 在 onBind() 方法中返回一个 Binder 的实例，之后 Activity 中实例化 ServiceConnection 接口对象， 其中有一个 IBinder 对象，将其强转为 BindService中返回的 Binder 类型，就可以在 Activity 中调用 Service 定义的 Binder 中的方法. 

1. 在 Service 定义 Binder 并 返回
 #+BEGIN_SRC java
@Override
public IBinder onBind(Intent intent) {
        return new TimerBinder();
    }
public class TimerBinder extends Binder{
        int id;
        public void start(){
            //通过定时器来安排计划
            timer.schedule(new TimerTask() {
                @Override
                public void run() {
                    //在指定的时间执行的任务
                    NotificationCompat.Builder builder = new NotificationCompat.Builder(getApplicationContext());
                    builder.setSmallIcon(android.R.drawable.ic_dialog_alert)
                            .setContentText("naozhong")
                            .setContentText("time is done....")
                            .setTicker("time is done....")
                            .setDefaults(Notification.DEFAULT_SOUND)
                            .setOngoing(true);
                    notificationManager.notify(2,builder.build());
                }
            }, 1 * 1000, 5000);
        }
        public void stop(){
            //关闭所有的定时任务
            timer.cancel();
            notificationManager.cancel(2);
        }
    }
 #+END_SRC

2. 在 Avtivity 中实例化一个 ServiceConnection 接口,并绑定 service
 #+BEGIN_SRC java
ServiceConnection conn = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            //绑定成功
            timerBinder = (TimerService.TimerBinder) service;

        }
        @Override
        public void onServiceDisconnected(ComponentName name) {
            //断开连接

        }
};
public void bindService(View V){
        bindService(new Intent(getApplicationContext(), TimerService.class), conn, BIND_AUTO_CREATE);
        //当绑定组件销毁时， Service 也会停止

    }


    public void unBindService(View V){
        unbindService(conn);//解除绑定
}
 #+END_SRC



*** AIDL
*** Messager 信使:跨进程通信
**** 服务端
1. 创建 Service 子类， 类中声明 handler 和 Messenger 类对象
 #+BEGIN_SRC java
//在 Service 子类中
 private Handler mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            //处理其他线程或进程发送过来的 Message
            Message replymsg = Message.obtain();
            replymsg.what = 2;
            try {
                msg.replyTo.send(replymsg);//应答客户端:向客户端回传消息
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    };
    private Messenger messenger = new Messenger(mHandler);
 #+END_SRC
2. 在 onBind() 方法中，获取 Messenger 的 IBinder 对象 并返回
 #+BEGIN_SRC java
 @Override
    public IBinder onBind(Intent intent) {

        return messenger.getBinder();//获取 Messenger 对象的 Ibinder 接口对象
    }
 #+END_SRC
3. 注册 Service 组件 并声明隐式启动或绑定组件的 Action
 #+BEGIN_SRC java
<service android:name=".PrintService">
            <intent-filter>
                <action android:name="alex.servicemessager"/>
            </intent-filter>
 </service>
 #+END_SRC
**** 客户端
1. 声明 Messenger 对象
 #+BEGIN_SRC java 
 private Messenger messenger;
 #+END_SRC
2. 声明 并实例化 ServiceConnection 接口对象，在绑定服务组件时使用，用于监听绑定是否成功
 #+BEGIN_SRC java
 private ServiceConnection conn = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            //绑定成功
            //实例化 Messenger 对象，将 IBinder 传入到Messenger 方法中
            messenger = new Messenger(service);
        }
        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };
 #+END_SRC
3. 在合适的位置调用 Context.bindService() 方法进行绑定
 #+BEGIN_SRC java
 bindService(new Intent("alex.servicemessager"),conn,BIND_AUTO_CREATE);
 #+END_SRC
4. 在 ServiceConnection 接口的 onServiceConnection() 方法中，将方法的第二个参数作为实例化Messenger 的构造方法参数使用
 : 在2步中已经顺便完成。
5. 在合适的位置调用 Messenger 对象的 send(Message msg) 向服务端的 Handler 中发送消息
  #+BEGIN_SRC java
Message msg = Message.obtain();
//msg.obj = "hello, Messenger Service"; 无法发送，String 类没有实现 Parcelable 接口
        Bundle data = new Bundle();
        data.putString("info","hello messenger");
        msg.setData(data);
        msg.replyTo = replyMessenger;
        messenger.send(msg);//通过信使向外部应用发送消息
    #+END_SRC

*** DownloadManager 下载管理器
**** 基本歩骤
1. 声明并实例化一个下载管理器
 #+BEGIN_SRC java
private DownloadManager downloadManager;//下载管理组件
//下载管理组件实例对象
downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE); 
 #+END_SRC
2. 得到网络下载的请求对象 request, 并存入指定位置
 #+BEGIN_SRC  java
//构造网络下载的请求对象
        DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));
        request.allowScanningByMediaScanner();
        request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);
        request.setTitle("downloading...");
        //保存位置
        request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS,"xx.xx");
 #+END_SRC
3. 将下载请求放入管理器
 #+BEGIN_SRC java
 downloadManager.enqueue(request);
 #+END_SRC

**** 如果下载的是视频，利用 VideoView 来播放
1. 承接上面3步，接受下载好的系统广播
 #+BEGIN_SRC java
 //获取下载请求的 id
        long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID,0);
 #+END_SRC
2. 根据id得到存储位置将位置发给要播放的 Activity
 #+BEGIN_SRC java
 //根据请求的id 获取下载之后的资源保存位置
        DownloadManager downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);
        Uri uri = downloadManager.getUriForDownloadedFile(id);
        Intent videoIntent = new Intent(context,VideoActivity.class);
        videoIntent.putExtra("path",
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)+"/xx.xx");
        videoIntent.putExtra("uri",uri);
        //创建新的任务栈来存放当前启动的 Activity 组件
        videoIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(videoIntent);
 #+END_SRC
3. 在新的 Activity 中播放
 #+BEGIN_SRC java
 //设置显示内容
setContentView(R.layout.activity_video);
//播放视频
videoView = (VideoView) findViewById(R.id.videoView);
//从意图中获取播放视频路径
//String path = getIntent().getStringExtra("path");
//videoView.setVideoPath(path);
Uri uri = getIntent().getParcelableExtra("uri");
videoView.setVideoURI(uri);
//设置 videoView 媒体控件 （进度 播放 暂停等等）
videoView.setMediaController(new MediaController(this));
 #+END_SRC
** BroadcastRecevier 
接受系统广播，组件间通信，子线程之间通讯
*** 三大要素
接受一个广播 需要  
- ACTION
- 权限
- 广播中包含的数据字段

*** 发送广播
实际上是发送的意图 Intent
1. 先定义常量
 #+BEGIN_SRC java
        //声明定时广播的 action， 存储数据的字段 EXTRA_TIME
    public static final String ACTION_TIMER="alex.broadcast.action.timer";
    public static final String EXTRA_TIME="time";

 #+END_SRC
2. 发送广播
   - 普通广播
    #+BEGIN_SRC java
    Intent timeIntent = new Intent(Config.ACTION_TIMER);
    timeIntent.putExtra(Config.EXTRA_TIME,time++);
    sendBroadcast(timeIntent);
    #+END_SRC

   - 有序广播
     #+BEGIN_SRC java
     sendOrderedBroadcast(new Intent(Config.ACTION_PRINT),"alex.permission.print");
     #+END_SRC

   - 带权限的广播
     #+BEGIN_SRC java
     sendBroadcast(new Intent(Config.ACTION_PRINT),permission);
     #+END_SRC

*** 接收广播的歩骤
1. 自定义广播接收器类，继承 BroadcastcReceiver，重写 onReceive()方法
   #+BEGIN_SRC java
   @Override
   public void onReceive(Context context, Intent intent) {
        //获取广播Action
        String action = intent.getAction();
        //获取广播数据，并显示到UI控件
        if(action == Intent.ACTION_BATTERY_CHANGED){
            int level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL,0);
            textView.setText("当前电量"+level+"%");
        }else if(action == Intent.ACTION_POWER_CONNECTED){
            textView.setText("电源连接");
        }else if(action == Intent.ACTION_POWER_DISCONNECTED){
            textView.setText("电源断开连接");
        }else if(action == Intent.ACTION_SCREEN_ON){
            textView.setText("打开屏幕");
        }
   }
   #+END_SRC
2. 注册广播接收器，通过 IntetnFilter 声明广播接收器可以接受的广播频道（Action）
   #+BEGIN_SRC java
        MyReciver myReciver = new MyReciver();
        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
        intentFilter.addAction(Intent.ACTION_BATTERY_LOW);
        //注册广播接收器，接受系统电量改变广播
        registerReceiver(myReciver, intentFilter);
   #+END_SRC


3. 在广播接受的方法中实现相关操作（在UI线程中执行）
   1. 启动 Activity
   2. 显示对话框，但是必须存在 Activity
   3. 启动 Service
   4. 发送通知
   5. 弹出 Toast

*** 本地广播
和普通广播的区别是需要一个 LocalBroadcastManager。
- 收广播
 #+BEGIN_SRC java
 //获取本地广播管理对象
 localBroadcastManager = LocalBroadcastManager.getInstance(getApplicationContext());
 networkReceiver = new NetworkReceiver();
 localBroadcastManager.registerReceiver(networkReceiver,new IntentFilter("alex.send2"));
 #+END_SRC
- 发广播
 #+BEGIN_SRC java
 //通过本地广播管理器来发送广播
 localBroadcastManager.sendBroadcast(intent);
 #+END_SRC



* 事件分发机制
简述: 
** 分发的核心方法
- dispatchTouchEvent
 事件分发的方法
 #+BEGIN_SRC java
 @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        //事件分发的方法
        Log.d("event",CLSNAME+"---dispatchTouchEvent"+ EventUtils.getName(ev));
        return super.dispatchTouchEvent(ev);
    }
 #+END_SRC
- onInterceptTouchEven
 拦截事件的方法
 #+BEGIN_SRC java
 @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        //拦截事件的方法
        Log.d("event",CLSNAME+"---onInterceptTouchEvent"+ EventUtils.getName(ev));
        if(ev.getAction()==MotionEvent.ACTION_MOVE){
            return true;//拦截后 子控件收到一个Cancel事件，拦截后如果不处理，交给父控件，如果处理返回 true，则处理
        }
        return super.onInterceptTouchEvent(ev);
    }
 #+END_SRC
- onTouchEvent 
  事件处理（消费）方法
 #+BEGIN_SRC java
 @Override
    public boolean onTouchEvent(MotionEvent event) {
        //事件处理（消费）方法
        Log.d("event",CLSNAME+"---onTouchEvent"+ EventUtils.getName(event));
        return super.onTouchEvent(event);
    }
 #+END_SRC

** 解决事件冲突
#+BEGIN_SRC java
//解决ListView与 ScrollView 的垂直滚动事件的冲突
        listView.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                //请求父控件不要拦截事件
                listView.getParent().requestDisallowInterceptTouchEvent(true);
                return false;
            }
        });
#+END_SRC
* 自定义控件
** 自定义控件三种类型
*** 扩展现有控件
**** 扩展基本控件 
- Button
- TextView
- ImageView

**** 扩展容器控件
- 布局控件
- ViewPager 控件
- ListView 控件

*** 完全自定义控件
- View 或 ViewGroup 类的子类
- 实现 onDraw() 方法来绘制内容
- 实现 onMeasure() 方法来计算 UI 控件大小
- 实现 onTouchEvent() 方法来处理触摸事件
- 自定义 UI 控件的属性

*** 定义高性能的控件
- SurfaceView 的子类
- 自定义相机
- 自定义视频播放器
- 游戏的画面显示
** 在继承的UI控件上绘图
- 实例一个Paint 画笔类
 一个画笔类可以设定画笔的颜色，边线，等等属性， 这一步在构建方法中完成
 #+BEGIN_SRC java
 //1. 声明并实例化画笔对象 Paint
 private Paint paint;
 paint = new Paint();
 paint.setColor(Color.RED);
 paint.setStrokeWidth(5);//px,像素
 paint.setAntiAlias(true);//抗锯齿
 #+END_SRC
- 在 onDraw(Canvas canvas) 方法中绘制
 #+BEGIN_SRC java
  //2. 绘制4条边线
        canvas.drawLine(0,0,getWidth(),0,paint);
        canvas.drawLine(0,0,0,getHeight(),paint);
        canvas.drawLine(0,getHeight(),getWidth(),getHeight(),paint);
        canvas.drawLine(getWidth(),0,getWidth(),getHeight(),paint);


 //绘制一个圆(圆心 半径)
        canvas.drawCircle(getWidth()/2,getHeight()/2,getHeight()/2-3,circlePaint);
 #+END_SRC
- 在 onTouchEvent(MotionEvent event) 方法中处理事件
 #+BEGIN_SRC java
 public boolean onTouchEvent(MotionEvent event) {
        // 触摸事件处理方法
        if(event.getAction() == MotionEvent.ACTION_DOWN){
            circlePaint.setColor(Color.GREEN);
            invalidate();//刷新 UI 控件
            setBackgroundColor(Color.CYAN);//按下设置背景
            //获取按下时的做变电
            pressedPoint = new Point((int)(event.getX()),(int)(event.getY()));
            return true; // 处理事件
        }else if (event.getAction() == MotionEvent.ACTION_UP){
            circlePaint.setColor(Color.argb(80,255,200,0));
            invalidate();//刷新 UI 控件
            setBackgroundColor(Color.WHITE);//抬起的背景
        }else if(event.getAction() == MotionEvent.ACTION_MOVE){
            //获取当前移动的点
            Point movePoint = new Point((int)(event.getX()),(int)(event.getY()));
            //计算偏移量
            int xDelta = movePoint.x - pressedPoint.x;
            int yDelta = movePoint.y - pressedPoint.y;

            //移动UI控件
            layout(getLeft()+xDelta,getTop()+yDelta,getRight()+xDelta,getBottom()+yDelta);
        }
        return super.onTouchEvent(event);
    }
 #+END_SRC

* 动画
** View 动画 - 补间动画
变化位置之间的动画，旋转平移缩放渐变等动画
*** 相关的类
*** 资源文件
- 位置 :: res/anim/xx.xml

** Drawable 动画 - 帧动画
帧动画就是把图片一张一张的连贯起来形成动画，用来做背景动画非常合适。
*** 歩骤 
1. 在资源中加入动画套图
2. 编写 xml 文件
 #+BEGIN_SRC xml
 <?xml version="1.0" encoding="utf-8"?>
 <animation-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@drawable/waiting_001" android:duration="100"/>
    <item android:drawable="@drawable/waiting_002" android:duration="100"/>
    <item android:drawable="@drawable/waiting_003" android:duration="100"/>
    <item android:drawable="@drawable/waiting_004" android:duration="100"/>
    <item android:drawable="@drawable/waiting_005" android:duration="100"/>
    <item android:drawable="@drawable/waiting_006" android:duration="100"/>
    <item android:drawable="@drawable/waiting_007" android:duration="100"/>
</animation-list>
 #+END_SRC
3. 将背景或其他的属性设置为 xml 文件命名
4. 在程序中添加
 #+BEGIN_SRC java
 AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground();
 animationDrawable.start();
 #+END_SRC
** Property 动画 - 属性动画
使用 Animator 来完成相关属性动画。Animator 将控件能改变的属性值连贯起来形成动画，比如 ImageView 有 setTranslationY() , setScaleX() 等属性设置，只需要添加初始值和结束值， Animator 就能将属性做成动画.
*** 在程序中使用
#+BEGIN_SRC java
//移动的属性动画
    public void translate(View v){
        //沿Y轴下移300px
        animator = ObjectAnimator.ofFloat(imageView, "translationY", 0, 300);
        animator.setDuration(3000);
        animator.setRepeatCount(ValueAnimator.INFINITE);
        animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new AccelerateDecelerateInterpolator());
        animator.start();
    }
#+END_SRC
容器控件的属性也可以做成动画
#+BEGIN_SRC java
public void bgAnim(View v){
        animator = ObjectAnimator.ofInt(imageView, "backgroundColor", Color.WHITE, Color.RED, Color.YELLOW, Color.BLUE, Color.GREEN);
        animator.setEvaluator((new ArgbEvaluator()));//颜色值的插值
        animator.setDuration(500);
        animator.setRepeatCount(ValueAnimator.INFINITE);
        animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.start();
    }
#+END_SRC
*** 直接使用 xml 写动画，在程序中导入
在 Activity 中
#+BEGIN_SRC java
public  void setAnimFromXml(View v){
        AnimatorSet animator = (AnimatorSet) AnimatorInflater.loadAnimator(this,R.animator.cc_anim);
        animator.setTarget(imageView);
        animator.start();
    }
#+END_SRC
R.animator.cc_anim:
#+BEGIN_SRC xml
<set xmlns:android="http://schemas.android.com/apk/res/android" android:ordering="sequentially">
    <objectAnimator
        android:duration="2000"
        android:propertyName="alpha"
        android:valueFrom="0"
        android:valueTo="1"
        android:valueType="floatType"/>

    <set android:ordering="together" >
        <objectAnimator android:propertyName="translationY"
            android:valueFrom="0"
            android:valueTo="200dp"
            android:duration="2000"/>
        <objectAnimator android:propertyName="rotation"
            android:valueFrom="0"
            android:valueTo="720"
            android:duration="2000"/>
    </set>
    <objectAnimator
        android:propertyName="scaleX"
        android:valueFrom="1.0"
        android:valueTo="0.2"
        android:duration="2000"
        android:valueType="floatType"
        />
    <objectAnimator
        android:propertyName="alpha"
        android:valueFrom="1"
        android:valueTo="0"
        android:duration="2000"
        />
</set>
#+END_SRC
* 第三方
** 第三方 SlidingMenu
侧边栏
*** 添加一个 xml 文件
*** 在 Activity 中使用
 1. 实例化 SlidingMenu 的对象
 2. 设置菜单的模式（左，右，左右）
 3. 设置菜单的内容（主菜单，次要菜单）
 4. 设置菜单布局显示的触摸方式 
    - none 无
    - margin 边缘
    - screen 整个屏幕
 5. 设置菜单布局的宽度
 6. 菜单显示的模式
    - content
    - window
**** 例子
MainActivity.java
#+BEGIN_SRC java
//1
private SlidingMenu slidMenu;
public onCreate(){
slidMenu = new SlidingMenu(getApplicationContext());
//2
slidMenu.setMode(SlidingMenu.LEFT_RIGHT);
//3
slidMenu.setMenu(R.layout.slidingmenu_left);
//设置次要菜单
slidMenu.setSceondaryMenu(R.layout.slidingmenu_second);
//4
slidMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
//5
slidMenu.setBehindWidth(300); //单位：像素
slidMenu.setBehindWidth(getResources().getDisplayMetrics().widthPixels * 0.75f);//设置为屏幕0.75
slidMenu.setBehindOffset(100);//设置菜单侧滑出来后，内容页面显示的宽度
//6
slidMenu.attachToActivity(this,SlidingMenu.SLIDING_WINDOW);
//设置监听
slidMenu.getMenu().findViewById(R.id.buttonId).setOnClickListener(this);
slidMenu.getSceondaryMenu().findViewById(R.id.buttonId2).setOnClickListener(this);
//隐藏菜单
slidMenu.toggle();
//启动 HomeButton 的导航
getActionBar().setDisplayShowHomeEnable(true);
getActionBar().setDisplayHomeAsUpRnable(true);
}
//在系统菜单的点击监听中
slidMenu.isMenuShowing();//是否显示
slidMenu.showMenu();//显示
slidMenu.toggle();//隐藏

#+END_SRC
** bdmap
: adb push vmp /mnt/....
离线数据包
: MKOfflineMap

OverlayOptions 常用地图图层类

*** 开始百度地图
1. 将工具包解压到工作控件， 如果是 Android Studio,其中的armeabi 文件夹需要放在 
 : src/main 
 目录下，或者依旧放在libs 文件夹下，但是要修改 gradle 
 : 在 android 下加上
 #+BEGIN_SRC java
 sourceSets {
         main {
             jniLibs.srcDirs = ['libs']
         }
 }
 #+END_SRC
2. 在清单文件中添加相关内容
   : AndroidMainifest
   #+BEGIN_SRC java
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="com.android.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="android.permission.WAKE_LOCK"/>
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.GET_TASKS" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>

<application
        <meta-data
            android:name="com.baidu.lbsapi.API_KEY"
            android:value="ELHDxaGogIPaV2R1HYYaEl3x" />
</application>
   
   #+END_SRC
3. 在 xml 中加入 com.baidu.mapapi.MapView 
   : acticity_main.xml
   #+BEGIN_SRC xml
        <com.baidu.mapapi.map.MapView
        android:id="@+id/bmapView"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"
        android:clickable="true" />
   #+END_SRC
4. 在 Activity 中初始化
   : MainActivity.java
   #+BEGIN_SRC java
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //这行添加在 setContentView 上面
        SDKInitializer.initialize(getApplicationContext());
        setContentView(R.layout.activity_main);
        mapView = (MapView) findViewById(R.id.bmapView);
        baiduMap = mapView.getMap();//获取地图 UI 的地图管理对象
    }
   #+END_SRC
5. 将离线地图导入到应用中
   : 在一个 Button 的单击事件中
   #+BEGIN_SRC java
   public void click(View view){
        MKOfflineMap mkOfflineMap = new MKOfflineMap();
        mkOfflineMap.init(new MKOfflineMapListener() {
            @Override
            public void onGetOfflineMapState(int type, int state) {
                if (type == MKOfflineMap.TYPE_NEW_OFFLINE) {
                    Log.d("cc","成功导入离线包，可以在下载管理查看");
                }
            }
        });
        int count = mkOfflineMap.importOfflineData(false);//导离线数据包,返回添加的个数
        if (count > 0 ){
            Log.d("cc","导入成功");
        }
    }
   #+END_SRC
这样一个基本的地图就出现在应用当中了
*** 为地图加标注
想为地图加一个自己的标注
#+BEGIN_SRC java
    public void addMarker(View v){
        MarkerOptions markerOptions = new MarkerOptions()
                .position(new LatLng(40.0,116.0))//维度  经度
                .icon(BitmapDescriptorFactory.fromResource(R.drawable.icon_marka))
                .title("自定义标注");
        //图片添加到地图
        baiduMap.addOverlay(markerOptions);
        //将地图的中心位置移动到标注位置并方法图层的级别
        baiduMap.setMapStatus(MapStatusUpdateFactory.newLatLngZoom(new LatLng(40.0,116.0),15));
        //第二种方法
//        baiduMap.setMapStatus(MapStatusUpdateFactory.newMapStatus(new MapStatus.Builder()
//                .target(new LatLng(40.0,116.0))
//                .zoom(15)
//                .rotate(45)
//                .overlook(45)
//                .build()));

        baiduMap.setOnMarkerClickListener(new BaiduMap.OnMarkerClickListener() {
            @Override
            public boolean onMarkerClick(Marker marker) {
                Toast.makeText(getApplicationContext(),
                        "--->"+marker.getTitle(),Toast.LENGTH_LONG).show();
                TextView textView = new TextView(getApplicationContext());
                textView.setText(marker.getTitle());
                textView.setBackgroundResource(R.drawable.popup);
                textView.setPadding(10, 20, 10, 20);
                textView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        //隐藏InfoMindow
                        baiduMap.hideInfoWindow();
                    }
                });
                //弹出信息窗口
                InfoWindow infoWindow = new InfoWindow(textView,marker.getPosition(),-150);
                baiduMap.showInfoWindow(infoWindow);
                return false;
            }
        });
    }
#+END_SRC

*** TODO 地图检索
表示是否首次定位

** Volley
*** 初步操作
1. StringRequest GET
2. JSONObject
3. ImageRequest

*** 图片加载
1. ImageRequest 加载 Bitmap
2. ImageLoader 加载
3. NetworkImageView 加载
**** ImageLoader
1. LruChche 构造方法，如果 LruCache 重写了 sizeOf(), 那么构造参数代表占用的最大内存尺寸
2. 如果 LruCache 补重写 sizeOf(),代表最多能存多少个对象

**** NewworkImageView
1. 两种加载方式
   1. ImageLoader 直接加载
   2. NewworkImageView 
*** 下载图片处理
1. 创建 ImageLoader 的ImageListener 监听器
2. 实例化 ImageLoader 同时实现 ImageCache 缓存
3. 通过 ImageLoader 加载图片资源，同时使用 ImageListener 监听

*** 三级缓存
#+BEGIN_SRC java

#+END_SRC

** XUtils
*** 客户端系统架构
*** 注解
**** 属性和参数
1. 需要在源代码开发时指定，不会改变
2. 代码中的注解在编译后，固化在 class 文件当中
3. 通过反射，可以获取成员变量的注解信息以及获取注解的参数
**** 一个例子
类型选择： Annotation , 类名 CodeAuthor

CodeAuthor.java
#+BEGIN_SRC java
//指定注解应用的位置
@Target(ElementType.FIELD)
//指定注解的作用范围 RUNTIME 代表在运行的时候可以获取注解
@Retention(RetentionPolicy.)
public @interface CodeAuthor{
//代表当前注解包含一个叫做 value 的属性
//在注解设置属性的时候，直接就是 value = xxx
//注解中 value 属于默认属性， 不需要写出来
//CodeAuthor()
    int value();

}
#+END_SRC
MainActivity.java
#+BEGIN_SRC java
//反射处理
Class c = this.getClass();
c.getDeclaredField("String");//成员变量
field.setAccessible(true);
//从成员变量中获取注解
CodeAuthor annotation = field.getAnnotation(CodeAuthor.class);
int v = annotation.value();
String str = getString(v);
//赋值
field.set(this,"Author:"+v);

@ResInject(id = R.string,app_name,type = ResType.String);
private String string;
@CodeAuthor(3)
private String string;
@CodeAuthor
private void test(){
    
}
#+END_SRC
fragment.java
#+BEGIN_SRC java
onCreateView(...){
   View view = ...;
   ViewUtils.inject(this,view);
   return view;
}
#+END_SRC


** 友盟 nmeng
http://www.umeng.com
- 主要提供软件使用的统计分析的功能。
- 提供推广信息
** ShareSDK
http://www.mob.com

*** 开发歩骤
* IDEA
** 常见问题
1. OLDER_SDK
 清单文件最小的版本高于手机版本,修改行单文件的最低版本即可.
2. 导入 support 支持包
 将支持包放入 libs 中，右键添加 add as Library
3. 编译正常，无法运行
 设置环境变量
   1. JAVA_HOME，不能用空格，如果用了，全部路径加上""
   2. ANDROID_HOME android SDK 根目录
   3. ANDROID_SDK_HOME android 模拟器存放的位置

** 快捷键
1. C+i 实现接口，抽象方法
2. C+o 重写方法
3. C+A+v 将变量提出成局部变量
4. 快速完成
   1. fori for循环的简写
5. C+A+f 提出成成员变量


* Android 高级课程
** 图片的加载与显示
*** 图片错位的第二种处理办法
**** 图片错位的原因
由于 ImageView 的复用， 异步任务的延迟， 可能造成一个 ImageView 加载多个异步任务的图片，造成图片闪烁或错位

在之前的 ListView 使用中使用 Tag 来防止图片错位， 简述如下：
1. ImageView 指定 Tag
2. AsyncTask 判断 Tag
3. Tag 就是图片地址
4. 在 getView() 中，getTag() 来防止错位


***** DONE 第二种办法
利用 ImageView 的 Drawable 对象来解决错位。 在 Drawable 中有一个 AsyncTask ，用来确保一个 ImageView 一个 AsyncTask

Google 官方代码
#+BEGIN_SRC java
static class AsyncDrawable extends BitmapDrawable {
    // 图片加载异步任务的弱引用
    private final WeakReference<BitmapWorkerTask> bitmapWorkerTaskReference;
    // 构造方法
    public AsyncDrawable(Resources res, Bitmap bitmap,
            BitmapWorkerTask bitmapWorkerTask) {
        super(res, bitmap);
        bitmapWorkerTaskReference =
            new WeakReference<BitmapWorkerTask>(bitmapWorkerTask);
    }
    // 暴露出来的得到异步任务的方法
    public BitmapWorkerTask getBitmapWorkerTask() {
        return bitmapWorkerTaskReference.get();
    }
}

// 之后在需要调用时调用这个方法
public void loadBitmap(int resId, ImageView imageView) {
    if (cancelPotentialWork(resId, imageView)) {
        final BitmapWorkerTask task = new BitmapWorkerTask(imageView);
        final AsyncsDrawable asyncDrawable =
                new AsyncDrawable(getResources(), mPlaceHolderBitmap, task);
        imageView.setImageDrawable(asyncDrawable);
        task.execute(resId);
    }
}
#+END_SRC

*** 图片缓存

**** DONE 内存缓存
1. 图片缓存使用二级缓存 （内存 + 文件）
2. 内存缓存， 储存的时 url -> Bitmap
3. 内存缓存命名 ImageCache 单例对象

***** LruCache
1. 使用 LRU 算法，最近最少使用原则
2. 构造方法需要设置缓存占用的最大值
3. 当创建 LruCache 没有重写 sizeOf 方法，最大参数表示代码能存多少个条目
4. 当创建的 LruCache 重写了 sizeOf 方法，参数就代表所有条目的尺寸的总和最大值
5. LruCache 内部存储采用强引用
**** 文件缓存
在之前的处理中都是得到一个图片 URL 的地址中个图片名称，这样做依旧有可能重名而且繁琐，现在利用 MD5 来命名。并且 Android 为程序设置了内存缓存，存放于
#+BEGIN_SRC java
Context.getExternalCacheDir() // 用来得到缓存目录
Context.getCacheDir() // 获取手机内部中的缓存目录
#+END_SRC
***** MD5 Hex编解码
MD5 即 MessageDegist 消息摘要 第五版，
#+BEGIN_SRC java
/**
 * 将网址映射为文件名
 */
public static String MD5(String url){
    String ret = null;
    if (url != null){
        try {
            // 创建消息摘要 使用MD5算法
            MessageDigest digest = MessageDigest.getInstance("MD5");
            byte[] data = digest.digest(url.getBytes());
            // 计算 url 对应的 MD5 生成的数据,内部包含了不可显示的字节，需要编码转化为字符串
            // 不要使用 new String(byte[]);  需要转化成0x
            // byte[] 每一个字节转换为 16进制 并且拼接成一个字符串
            ret = toHex(data);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
    return ret;
}
/**
 * 将字节数组转化为16进制编码字符串
 */
public static String toHex(byte[] data){
    String ret = null;
    if (data != null && data.length > 0 ){
        StringBuilder stringBuilder = new StringBuilder();
        for (byte b : data){
            int v = b & 0x0FF;
            String hex = Integer.toHexString(v);
            if (v > 0x0F){
                stringBuilder.append(hex);
            }else {
                stringBuilder.append('0').append(hex);
            }
        }
        ret = stringBuilder.toString();
    }
    return ret;  
}
#+END_SRC

**** 图片加载任务升级版
- 异步任务中 ImageView 变量采用弱引用方式
- 使用弱引用是为了避免 Activity 或 UI 在销毁后异步任务还保存着对象引用的问题。
*** DONE 处理大图片
大图片直接载入容易出现 OOM(OutOfMemoryError) 内存溢出错误，需要使用图片二次采样

在 BitmapFactory中可以设置只取得图片的尺寸，再根据实际宽高进行计算，得到一个缩小倍数，达到将图片缩小的目的
**** Options 说明
- 成员变量作为配置信息传给解码器
- 变量分为两部分 in... out...
  - in... 用于给解码器传递参数
  - out... 用于从解码器获取结果

**** java 代码
#+BEGIN_SRC java
private Bitmap getBitmapUseOption(Bitmap ret, byte[] data) {
        BitmapFactory.Options options = new BitmapFactory.Options();
        // 设置 inJustDecodeBounds 来控制解码器 只进行图片宽高的获取 不加载，不占内存
        options.inJustDecodeBounds = true;
        // 使用Options 参数设置解码方式
        ret = BitmapFactory.decodeByteArray(data,0,data.length,options);


        // ----- 根据图片真是尺寸雨当前需要显示的尺寸进行计算生成采样率

        // 准备显示在手机上
        int reqW = requestWidth;
        int reqH = requestHeight;

        // 计算设置图片采样率
        options.inSampleSize = calculateInSampleSize(options,reqW,reqH);// 宽度的 1／32

        // 开放解码 实际生成 Bitmap
        options.inJustDecodeBounds = false;
        // 使用 565 方式解码
        options.inPreferredConfig = Bitmap.Config.RGB_565;
        ret = BitmapFactory.decodeByteArray(data,0,data.length,options);
        return ret;
    }

    /**
     * 计算图片二次采样的采样率，使用获取图片宽高之后的 option参数 作为第一个参数
     * @param options options
     * @param reqWidth 请求宽度
     * @param reqHeight 请求高度
     * @return int 采样率
     */
    public static int calculateInSampleSize(
            BitmapFactory.Options options, int reqWidth, int reqHeight) {
        // Raw height and width of image
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 1;

        // 请求高度宽度 > 0 进行缩放
        if (reqHeight > 0 && reqWidth > 0){

            if (height > reqHeight || width > reqWidth) {

                final int halfHeight = height / 2;
                final int halfWidth = width / 2;

                // Calculate the largest inSampleSize value that is a power of 2 and keeps both
                // height and width larger than the requested height and width.
                while ((halfHeight / inSampleSize) > reqHeight
                        && (halfWidth / inSampleSize) > reqWidth) {
                    inSampleSize *= 2;
                }
            }
        }
        return inSampleSize;
    }
#+END_SRC

** TODO 复杂的 ListView 应用
*** 购物车
#+BEGIN_QUOTE
在一个购物车中，ListView 的每条内容都有可以点击的按钮，比如 增加或减少商品数量，点击图片进入详情页等等，这里就对这样复杂的 LstView 使用做一个笔记
#+END_QUOTE
- 首先，ListView 所有的 Item 都不直接控制 UI 状态，而是使用 Adapter 来更新，ListView 的更新永远时刷新数据
- ListView内部 Item 中，包含按钮，给按钮设置 Tag 来进行点击事件的支持
总结起来，所有的更新 UI 都由
: notifyDataChanged()来完成
而一些状态可以由实体类来记录，比如商品是否选择，减少商品时，当数量为0时的状态。而在 Adapter 中对这些状态进行判断，因为 Item 重用的原因，并不在 Adapter 中更新UI，而是采用接口回调的方式来在 Activity 或者 Fragment 中进行更新，当然，需要通过设置 Tag 来令控件可以被找到

#+BEGIN_QUOTE
需要注意的是： 在所有变化进行之前，必须先设置 Tag，如果先设置状态，就会先调用监听方法，很可能使用的 Tag 就是之前的位置的数据，而达不到预期的目的
#+END_QUOTE
**** ListView 的焦点冲突
当 ListView 的条目中有带有焦点的控件比如 Button 时，系统会对焦点进行检测，如果当前控件由焦点，则判断点击事件是否点中焦点， 如果焦点被抢夺，ListView 条目中的点击事件就会无效，而一个行之有效的方法就是使用
: focusable="false"
或 在 Item 容器顶部的XML 标签中
: descendantFocusability=“blockDescendants”
这个方法无法解决与 EditView 的冲突问题。
**** Adapter 更新触发外部处理
在购物车中，每次点击加减或者添加删除，都需要改变总金额， Adapter 提供了一种观察者模式来方便的检测更新，然后通知 Activity 或者 Fragment

注册观察者使用 registerDataSetObserver


** 常见的 Android 开发模式
1. 异步任务回调
2. 充分使用 Android 组件的模式 Service ContentProvider Loader BroadcastRecevier
3. 第三方框架的模式

*** TODO 项目接口请求 Task 模式歩骤
1. ClientAPI 实现网址的请求，提供参数的设置，返回结果
2. Task 异步任务的定义 : 调用 ClientAPI
3. 实体工具类 解析 JSON 数据
4. Task 最终返回 TaskResult
5. UI 启动 Task
6. 异步任务数据的接受， TaskCallback 实现


** 关于 ScrollView + ListView
1. 所有的容器在显示内容之前都需要进行排版，排版时需要获取内部子控件/子容器的尺寸
2. 所有的 View 内部有一个回调方法， onMeasure 这个方法就是实际控件自身测量自己尺寸的方法；
3. onMeasure 实际上就是控件自己算自己的尺寸
4. 当 ListView 被 ScrollView 包含的时候，那么 onMeasure方法接受的参数就有一些不同普通情况 wrap_content 会对应一个参数模式，称作 AT_MOST
5. match_parent 对应 EXACTLY
6. 只有 ScrollView 内部控件进行尺寸计算(onMeasure)的时候，参数模式时 UNSPECIFIED
   ListView onMeasure 方法，检测模式如果时 UNSPECIFIED,永远只有一行



** 打包、发布
1. 经过大量的内部测试:开发人员自己测试，单元测试包括大量的功能测试、性能测试，与服务器联调(最好可以动态修改服务器位置)
2. 软件包发布时，使用 Release 版本，需要进行软件测试，测试需要配置软件包 release 版本的数字签名
3. KeyStore 文件: 内部包含了非对称加密的公钥和私钥，私钥用于对生成的 apk包进行数字签名，同时将公钥打包到 apk 文件中，形成数字签名的验证，使用公钥判断 apk 软件是否被非法修改过。
4. 当 apk 数字签名验证通过，才可以安装到手机上，或者提交到应用市场中。
5. 因为 apk 包中包含了 公钥(证书) 就包含了软件作者

*** Gradle 对于数字签名的处理
通常都是 release 版本才签名， debug 版本使用 android SDK 提供的debug.keystore 来签名

歩骤
- 准备 keystore 文件，如果公司有那么使用公司的，否则使用工具生成证书
- 在模块的 build.gradle 中，来配置 keystore 的信息
- build.gradle 为每一个应用程序发布的渠道进行签名 keystore 的设置

针对以上歩骤详细解释如下
**** 生成 keystore 文件
示例
在工程目录下进入 terminal 
: keytool -genkeypair -alias alex_release -validity 10000 -keystore release.keystore -storepass 123456 -keypass 654321 

**** 编译
Gradle build

**** gradle 的设置
#+BEGIN_SRC java
// 数字签名文件的配置,
signingConfigs {
        config {
            keyAlias 'alex_release'
            keyPassword '654321'
            // 相对于当前目录
            // 如果文件在 app 目录下 release.keystore
            // 如果在上一级 ../release.keystore
            storeFile file('/home/alex/AndroidStudioProjects/XmlyFM/release.keystore')
            storePassword '123456'
        }
}

#+END_SRC
在android节点下
#+BEGIN_SRC java
    // 忽略一些不规范代码
    lintOptions{
        abortOnError false
    }
#+END_SRC

*** Gradle 多渠道
* 收藏的网页
** 酷炫的 UI 效果
https://github.com/wasabeef/awesome-android-ui

** W3C
http://www.w3school.com.cn
** SQL
http://sqlite.org/
* 常用<<工具类>>
** json解析规则
1. 必须区分出来那些可选那些不可选
2. optXXXX(String key) 查找 JSON 对象中的字段

** HttpUtil
#+BEGIN_SRC java
  public static InputStream getInputStream(String path) throws IOException {
          InputStream inputStream = null;
          URL url = new URL(path);
          HttpURLConnection connection = (HttpURLConnection) url.openConnection();
          connection.setRequestMethod("GET");
          connection.setReadTimeout(50000);
          connection.getDoInput();
          connection.connect();
          if(connection.getResponseCode()==200){
              inputStream = connection.getInputStream();
          }
          return inputStream;
      }
  
      public static String InputStream2String(InputStream inputStream) throws IOException {
          int len = 0;
          byte[] buf = new byte[1024];
          StringBuffer sb = new StringBuffer();
          while((len = inputStream.read(buf)) != -1){
              sb.append(new String(buf,0,len,"UTF-8"));
          }
          return sb.toString();
      }
  
      public static byte[] InputStream2byte(InputStream inputStream) throws IOException {
          int len = 0;
          byte[] buf = new byte[1024];
          ByteArrayOutputStream bos = new ByteArrayOutputStream();
          while((len = inputStream.read(buf))!= -1){
              bos.write(buf,0,len);
          }
          return bos.toByteArray();
      }
  
#+END_SRC
** XmlPullParseUtil
#+BEGIN_SRC java
  //一个解析城市的例子
  public static List<Province> xmlPaese(InputStream inputStream) throws XmlPullParserException, IOException {
          List<Province> provinces = null;
          Province province = null;
          String tagName = null;
          List<City> cities = null;
          City city = null;
          List<District> districts = null;
          District district;
          XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
          XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
          xmlPullParser.setInput(inputStream,"UTF-8");
          int event = xmlPullParser.getEventType();
          while(event != XmlPullParser.END_DOCUMENT){
              switch(event){
                  case XmlPullParser.START_DOCUMENT:
                      provinces = new ArrayList<>();
                      break;
                  case XmlPullParser.START_TAG:
                      tagName = xmlPullParser.getName();
                      if("p".equals(tagName)){
                          province = new Province();
                          cities = new ArrayList<>();
  
                          int count = xmlPullParser.getAttributeCount();
                          for(int i = 0; i < count; i++){
                              String name = xmlPullParser.getAttributeName(i);
                              String value = xmlPullParser.getAttributeValue(i);
                              if("p_id".equals(name)){
                                  province.setId(value);
                              }
                          }
                      }else if("pn".equals(tagName)){
                          province.setName(xmlPullParser.nextText());
                      }else if("c".equals(tagName)){
                              city = new City();
                              districts = new ArrayList<>();
  
                          int count = xmlPullParser.getAttributeCount();
                              for(int i = 0; i < count; i++){
                                  String name = xmlPullParser.getAttributeName(i);
                                  String value = xmlPullParser.getAttributeValue(i);
                                  if("c_id".equals(name)){
                                      city.setId(value);
                                  }
                              }
                          }else if("cn".equals(tagName)){
                              city.setName(xmlPullParser.nextText());
                          }else if("d".equals(tagName)){
                              district = new District();
                              int count = xmlPullParser.getAttributeCount();
                              for(int i = 0; i < count; i++){
                                  String name = xmlPullParser.getAttributeName(i);
                                  String value = xmlPullParser.getAttributeValue(i);
                                  if("d_id".equals(name)){
                                      district.setId(value);
                                  }
                                  district.setName(xmlPullParser.nextText());
                                  districts.add(district);
                              }
                          }
  
                          break;
                      case XmlPullParser.END_TAG:
  
                          if("c".equals(xmlPullParser.getName())){
                              city.setDistricts(districts);
                              cities.add(city);
                          }else if("p".equals(xmlPullParser.getName())){
  
                              province.setCitys(cities);
                              provinces.add(province);
                          }
                          break;
                  }
                  event = xmlPullParser.next();
          }
          return provinces;
      }
#+END_SRC
** JsonParseUtil
#+BEGIN_SRC java
  //一个解析天气情况的例子
  static public List<WeatherInfo> parseWeather(String jsonString) throws JSONException {
          List<WeatherInfo> list = new ArrayList<>();
          JSONObject object = new JSONObject(jsonString);
          JSONArray data = object.getJSONArray("data");
          for(int i = 0; i < data.length(); i++){
              String date = data.getJSONObject(i).getString("date");
              String icon = data.getJSONObject(i).getString("icon");
              String weather = data.getJSONObject(i).getString("weather");
              String temperature = data.getJSONObject(i).getString("temperature");
              String winddirect = data.getJSONObject(i).getString("winddirect");
              Log.d("json======",data+icon+weather+temperature+winddirect);
              list.add(new WeatherInfo(date,icon,weather,temperature,winddirect));
          }
          return list;
      }
  
#+END_SRC

#+BEGIN_SRC java
//一个 json 例子
String jsonString = new String(bytes,"utf-8");
        JSONObject obj = null;
        obj = new JSONObject(jsonString).getJSONObject("cities");
        Gson gson = new Gson();
        TypeToken<List<City>> token = new TypeToken<List<City>>(){};
        List<City> temp1 = gson.fromJson(obj.getJSONArray("hotcities").toString(), token.getType());
        list.add(new City("hotcities", "label"));
        list.addAll(temp1);
        for (int i = 0; i < 'Z' - 'A'; i++) {
            String str = new String((char) ('A' + i) + "");
            try {
                JSONArray arr = obj.getJSONArray(str);
                list.add(new City(str, "label"));
                listRight.add(str);
                List<City> temp = gson.fromJson(arr.toString(), token.getType());
                list.addAll(temp);
            } catch (JSONException e) {
                Log.d("json", "没这个字母" + str);
            }
        }
#+END_SRC

** FileUtil
缓存图片的例子
#+BEGIN_SRC java
  //存储图片的目录
  public static final String IMAGE_URL = Environment.getExternalStorageDirectory()+"/xx/images";
  //判断是否挂载扩展卡
  public static  boolean isMounted(){
      String state = Environment.getExternalStorageState();
      state.equals(Environment.MEDIA_MOUNTED);
  }
  //保存图片到目录
  public static  void saveImage(String url, byte[] data){
      if(!isMounted()){
          return;
      }
      File dir = new File(IMAGE_URL);
      if(!dir.exists()){
          dir.mkdirs();
      }
      FileOutputStream fos = new FileOutputStream(new File(dir,getFileName(url)));
      fos.write(data);
      fos.close();
  }
  //读取图片
  public static Bitmap readImage(String url){
      String fileName = getFileName(utl);
      File file = new File(dir,fileName);
      Bitmap Bitmap = BitmapFactory.decodeFile(file.getAbsolutePath());
      return biemap;
  }
  //判断剩余控件
  public staic boolean isAble(){
      StatFs fs = new StatFs(Environment.getExternalStorageDirectory().getAbsolutePath());
      int count = fs.getFreeBlocks();//获取空闲的数据块个数
      fs.getBlockSize();//获取每块数据块大小
      long total = count * size;
  
      int t = (int)(total/1024/1024);
      if(t>2)
          return true;
      else 
          return false;
  }
  //清空扩展卡
  public staic void clear(){
      String path = Environment.getExternalStorageDirectory.getAbsolutePath();
  
      File dir = new File(Environment.getExternalStorageDirectory());
  
  }
  
  public static String getFileName(String url){
      url.substring(url.lastIndexOf("/")+1);
  }
#+END_SRC


# * 老师信息
# ** 狄老师
# *** QQ
# 610039018
# *** email
# ahhqdyh@aliyun.com

useLibrary "org.apache.http.legacy"




** 图片缓存 FileCache
FileCache.java
#+BEGIN_SRC java
public class FileCache {
    private static FileCache ourInstance;

    public static FileCache newInstance(Context context){
        if (context != null){

            if (ourInstance == null) {
                ourInstance = new FileCache(context);
            }

        }else{
            throw new IllegalArgumentException("Context must be set");

        }

        return ourInstance;
    }

    public static FileCache getInstance(){
        if (ourInstance == null){
            throw new IllegalStateException("newInstance invoke");
        }
        return ourInstance;
    }

    private Context context;
    private FileCache(Context context) {
        this.context = context;
    }


    /**
     * 将字节数组转化为16进制编码字符串
     * @param data
     * @return
     */
    public static String toHex(byte[] data){
        String ret = null;
        if (data != null && data.length > 0 ){
            StringBuilder stringBuilder = new StringBuilder();
            for (byte b : data){
                int v = b & 0x0FF;
                String hex = Integer.toHexString(v);
                if (v > 0x0F){
                    stringBuilder.append(hex);
                }else {
                    stringBuilder.append('0').append(hex);
                }
            }
            ret = stringBuilder.toString();
        }
        return ret;
    }

    /**
     * 将网址映射为文件名
     * @param url
     * @return
     */
    public static String mapFile(String url){
        String ret = null;
        if (url != null){
            try {
                // 创建消息摘要 使用MD5算法
                MessageDigest digest = MessageDigest.getInstance("MD5");
                byte[] data = digest.digest(url.getBytes());
                // 计算 url 对应的 MD5 生成的数据,内部包含了不可显示的字节，需要编码转化为字符串
                // 不要使用 new String(byte[]);  需要转化成0x

                // byte[] 每一个字节转换为 16进制 并且拼接成一个字符串

                ret = toHex(data);

            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
        }
        return ret;
    }

    /**
     * 从文件存储加载对应网址的内容
     * @param url
     * @return
     */
    public byte[] load(String url){
        // 通过网址找文件
        byte[] ret = null;

        if (url != null){
            // 最终的文件缓存目录
            File cacheDir = null;

            String state = Environment.getExternalStorageState();
            if (Environment.MEDIA_BAD_REMOVAL.equals(state)){
                // 获取存储卡的缓存目录
                cacheDir = context.getExternalCacheDir();

            }else {
                // 内部缓存
                cacheDir = context.getCacheDir();
            }

            // 映射文件名成
            String fileName = mapFile(url);
            File targetFile = new File(cacheDir,fileName);
            if (targetFile.exists()){
                ByteArrayOutputStream bout = null;
                FileInputStream fin = null;
                try {
                    fin = new FileInputStream(targetFile);

                    bout = new ByteArrayOutputStream();

                    byte[] buf = new byte[128];
                    int len;
                    while (true){
                        len = fin.read(buf);
                        if (len == -1){
                            break;
                        }
                        bout.write(buf,0,len);

                    }

                    // buf 比需要进行 = null 的操作
                    // 减少内存溢出的可能性， 让 gc 可以回收
                    buf = null;

                    ret = bout.toByteArray();

                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    if (fin != null){
                        try {
                            fin.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    if (bout != null){
                        try {
                            bout.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        return ret;
    }

    /**
     * 保存对应网址的数据到文件中
     * @param url
     * @param data
     */
    public void save(String url, byte[] data){
        // 通过网址存文件

        if (url != null && data != null){

            // 最终的文件缓存目录
            File cacheDir = null;

            String state = Environment.getExternalStorageState();
            if (Environment.MEDIA_BAD_REMOVAL.equals(state)){
                // 获取存储卡的缓存目录
                cacheDir = context.getExternalCacheDir();

            }else {
                // 内部缓存
                cacheDir = context.getCacheDir();
            }

            // 映射文件名成
            String fileName = mapFile(url);
            File targetFile = new File(cacheDir,fileName);
            //IO
            FileOutputStream fout = null;
            try {
                fout = new FileOutputStream(targetFile);
                fout.write(data);
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (fout != null) {
                    try {
                        fout.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }

        }
    }

}

#+END_SRC
